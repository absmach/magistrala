// Copyright (c) Abstract Machines

// SPDX-License-Identifier: Apache-2.0

// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/absmach/magistrala/bootstrap"
	mock "github.com/stretchr/testify/mock"
)

// NewConfigRepository creates a new instance of ConfigRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConfigRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConfigRepository {
	mock := &ConfigRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ConfigRepository is an autogenerated mock type for the ConfigRepository type
type ConfigRepository struct {
	mock.Mock
}

type ConfigRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *ConfigRepository) EXPECT() *ConfigRepository_Expecter {
	return &ConfigRepository_Expecter{mock: &_m.Mock}
}

// ChangeState provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) ChangeState(ctx context.Context, domainID string, id string, state bootstrap.State) error {
	ret := _mock.Called(ctx, domainID, id, state)

	if len(ret) == 0 {
		panic("no return value specified for ChangeState")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, bootstrap.State) error); ok {
		r0 = returnFunc(ctx, domainID, id, state)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_ChangeState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeState'
type ConfigRepository_ChangeState_Call struct {
	*mock.Call
}

// ChangeState is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - id string
//   - state bootstrap.State
func (_e *ConfigRepository_Expecter) ChangeState(ctx interface{}, domainID interface{}, id interface{}, state interface{}) *ConfigRepository_ChangeState_Call {
	return &ConfigRepository_ChangeState_Call{Call: _e.mock.On("ChangeState", ctx, domainID, id, state)}
}

func (_c *ConfigRepository_ChangeState_Call) Run(run func(ctx context.Context, domainID string, id string, state bootstrap.State)) *ConfigRepository_ChangeState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 bootstrap.State
		if args[3] != nil {
			arg3 = args[3].(bootstrap.State)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *ConfigRepository_ChangeState_Call) Return(err error) *ConfigRepository_ChangeState_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_ChangeState_Call) RunAndReturn(run func(ctx context.Context, domainID string, id string, state bootstrap.State) error) *ConfigRepository_ChangeState_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectClient provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) ConnectClient(ctx context.Context, channelID string, clientID string) error {
	ret := _mock.Called(ctx, channelID, clientID)

	if len(ret) == 0 {
		panic("no return value specified for ConnectClient")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, channelID, clientID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_ConnectClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectClient'
type ConfigRepository_ConnectClient_Call struct {
	*mock.Call
}

// ConnectClient is a helper method to define mock.On call
//   - ctx context.Context
//   - channelID string
//   - clientID string
func (_e *ConfigRepository_Expecter) ConnectClient(ctx interface{}, channelID interface{}, clientID interface{}) *ConfigRepository_ConnectClient_Call {
	return &ConfigRepository_ConnectClient_Call{Call: _e.mock.On("ConnectClient", ctx, channelID, clientID)}
}

func (_c *ConfigRepository_ConnectClient_Call) Run(run func(ctx context.Context, channelID string, clientID string)) *ConfigRepository_ConnectClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConfigRepository_ConnectClient_Call) Return(err error) *ConfigRepository_ConnectClient_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_ConnectClient_Call) RunAndReturn(run func(ctx context.Context, channelID string, clientID string) error) *ConfigRepository_ConnectClient_Call {
	_c.Call.Return(run)
	return _c
}

// DisconnectClient provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) DisconnectClient(ctx context.Context, channelID string, clientID string) error {
	ret := _mock.Called(ctx, channelID, clientID)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectClient")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, channelID, clientID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_DisconnectClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisconnectClient'
type ConfigRepository_DisconnectClient_Call struct {
	*mock.Call
}

// DisconnectClient is a helper method to define mock.On call
//   - ctx context.Context
//   - channelID string
//   - clientID string
func (_e *ConfigRepository_Expecter) DisconnectClient(ctx interface{}, channelID interface{}, clientID interface{}) *ConfigRepository_DisconnectClient_Call {
	return &ConfigRepository_DisconnectClient_Call{Call: _e.mock.On("DisconnectClient", ctx, channelID, clientID)}
}

func (_c *ConfigRepository_DisconnectClient_Call) Run(run func(ctx context.Context, channelID string, clientID string)) *ConfigRepository_DisconnectClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConfigRepository_DisconnectClient_Call) Return(err error) *ConfigRepository_DisconnectClient_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_DisconnectClient_Call) RunAndReturn(run func(ctx context.Context, channelID string, clientID string) error) *ConfigRepository_DisconnectClient_Call {
	_c.Call.Return(run)
	return _c
}

// ListExisting provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) ListExisting(ctx context.Context, domainID string, ids []string) ([]bootstrap.Channel, error) {
	ret := _mock.Called(ctx, domainID, ids)

	if len(ret) == 0 {
		panic("no return value specified for ListExisting")
	}

	var r0 []bootstrap.Channel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) ([]bootstrap.Channel, error)); ok {
		return returnFunc(ctx, domainID, ids)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) []bootstrap.Channel); ok {
		r0 = returnFunc(ctx, domainID, ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bootstrap.Channel)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = returnFunc(ctx, domainID, ids)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConfigRepository_ListExisting_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExisting'
type ConfigRepository_ListExisting_Call struct {
	*mock.Call
}

// ListExisting is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - ids []string
func (_e *ConfigRepository_Expecter) ListExisting(ctx interface{}, domainID interface{}, ids interface{}) *ConfigRepository_ListExisting_Call {
	return &ConfigRepository_ListExisting_Call{Call: _e.mock.On("ListExisting", ctx, domainID, ids)}
}

func (_c *ConfigRepository_ListExisting_Call) Run(run func(ctx context.Context, domainID string, ids []string)) *ConfigRepository_ListExisting_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConfigRepository_ListExisting_Call) Return(channels []bootstrap.Channel, err error) *ConfigRepository_ListExisting_Call {
	_c.Call.Return(channels, err)
	return _c
}

func (_c *ConfigRepository_ListExisting_Call) RunAndReturn(run func(ctx context.Context, domainID string, ids []string) ([]bootstrap.Channel, error)) *ConfigRepository_ListExisting_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) Remove(ctx context.Context, domainID string, id string) error {
	ret := _mock.Called(ctx, domainID, id)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, domainID, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type ConfigRepository_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - id string
func (_e *ConfigRepository_Expecter) Remove(ctx interface{}, domainID interface{}, id interface{}) *ConfigRepository_Remove_Call {
	return &ConfigRepository_Remove_Call{Call: _e.mock.On("Remove", ctx, domainID, id)}
}

func (_c *ConfigRepository_Remove_Call) Run(run func(ctx context.Context, domainID string, id string)) *ConfigRepository_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConfigRepository_Remove_Call) Return(err error) *ConfigRepository_Remove_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_Remove_Call) RunAndReturn(run func(ctx context.Context, domainID string, id string) error) *ConfigRepository_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveChannel provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) RemoveChannel(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_RemoveChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveChannel'
type ConfigRepository_RemoveChannel_Call struct {
	*mock.Call
}

// RemoveChannel is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *ConfigRepository_Expecter) RemoveChannel(ctx interface{}, id interface{}) *ConfigRepository_RemoveChannel_Call {
	return &ConfigRepository_RemoveChannel_Call{Call: _e.mock.On("RemoveChannel", ctx, id)}
}

func (_c *ConfigRepository_RemoveChannel_Call) Run(run func(ctx context.Context, id string)) *ConfigRepository_RemoveChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConfigRepository_RemoveChannel_Call) Return(err error) *ConfigRepository_RemoveChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_RemoveChannel_Call) RunAndReturn(run func(ctx context.Context, id string) error) *ConfigRepository_RemoveChannel_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveClient provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) RemoveClient(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveClient")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_RemoveClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveClient'
type ConfigRepository_RemoveClient_Call struct {
	*mock.Call
}

// RemoveClient is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *ConfigRepository_Expecter) RemoveClient(ctx interface{}, id interface{}) *ConfigRepository_RemoveClient_Call {
	return &ConfigRepository_RemoveClient_Call{Call: _e.mock.On("RemoveClient", ctx, id)}
}

func (_c *ConfigRepository_RemoveClient_Call) Run(run func(ctx context.Context, id string)) *ConfigRepository_RemoveClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConfigRepository_RemoveClient_Call) Return(err error) *ConfigRepository_RemoveClient_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_RemoveClient_Call) RunAndReturn(run func(ctx context.Context, id string) error) *ConfigRepository_RemoveClient_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveAll provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) RetrieveAll(ctx context.Context, domainID string, clientIDs []string, filter bootstrap.Filter, offset uint64, limit uint64) bootstrap.ConfigsPage {
	ret := _mock.Called(ctx, domainID, clientIDs, filter, offset, limit)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveAll")
	}

	var r0 bootstrap.ConfigsPage
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string, bootstrap.Filter, uint64, uint64) bootstrap.ConfigsPage); ok {
		r0 = returnFunc(ctx, domainID, clientIDs, filter, offset, limit)
	} else {
		r0 = ret.Get(0).(bootstrap.ConfigsPage)
	}
	return r0
}

// ConfigRepository_RetrieveAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveAll'
type ConfigRepository_RetrieveAll_Call struct {
	*mock.Call
}

// RetrieveAll is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - clientIDs []string
//   - filter bootstrap.Filter
//   - offset uint64
//   - limit uint64
func (_e *ConfigRepository_Expecter) RetrieveAll(ctx interface{}, domainID interface{}, clientIDs interface{}, filter interface{}, offset interface{}, limit interface{}) *ConfigRepository_RetrieveAll_Call {
	return &ConfigRepository_RetrieveAll_Call{Call: _e.mock.On("RetrieveAll", ctx, domainID, clientIDs, filter, offset, limit)}
}

func (_c *ConfigRepository_RetrieveAll_Call) Run(run func(ctx context.Context, domainID string, clientIDs []string, filter bootstrap.Filter, offset uint64, limit uint64)) *ConfigRepository_RetrieveAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		var arg3 bootstrap.Filter
		if args[3] != nil {
			arg3 = args[3].(bootstrap.Filter)
		}
		var arg4 uint64
		if args[4] != nil {
			arg4 = args[4].(uint64)
		}
		var arg5 uint64
		if args[5] != nil {
			arg5 = args[5].(uint64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *ConfigRepository_RetrieveAll_Call) Return(configsPage bootstrap.ConfigsPage) *ConfigRepository_RetrieveAll_Call {
	_c.Call.Return(configsPage)
	return _c
}

func (_c *ConfigRepository_RetrieveAll_Call) RunAndReturn(run func(ctx context.Context, domainID string, clientIDs []string, filter bootstrap.Filter, offset uint64, limit uint64) bootstrap.ConfigsPage) *ConfigRepository_RetrieveAll_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveByExternalID provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) RetrieveByExternalID(ctx context.Context, externalID string) (bootstrap.Config, error) {
	ret := _mock.Called(ctx, externalID)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveByExternalID")
	}

	var r0 bootstrap.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bootstrap.Config, error)); ok {
		return returnFunc(ctx, externalID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bootstrap.Config); ok {
		r0 = returnFunc(ctx, externalID)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, externalID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConfigRepository_RetrieveByExternalID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveByExternalID'
type ConfigRepository_RetrieveByExternalID_Call struct {
	*mock.Call
}

// RetrieveByExternalID is a helper method to define mock.On call
//   - ctx context.Context
//   - externalID string
func (_e *ConfigRepository_Expecter) RetrieveByExternalID(ctx interface{}, externalID interface{}) *ConfigRepository_RetrieveByExternalID_Call {
	return &ConfigRepository_RetrieveByExternalID_Call{Call: _e.mock.On("RetrieveByExternalID", ctx, externalID)}
}

func (_c *ConfigRepository_RetrieveByExternalID_Call) Run(run func(ctx context.Context, externalID string)) *ConfigRepository_RetrieveByExternalID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConfigRepository_RetrieveByExternalID_Call) Return(config bootstrap.Config, err error) *ConfigRepository_RetrieveByExternalID_Call {
	_c.Call.Return(config, err)
	return _c
}

func (_c *ConfigRepository_RetrieveByExternalID_Call) RunAndReturn(run func(ctx context.Context, externalID string) (bootstrap.Config, error)) *ConfigRepository_RetrieveByExternalID_Call {
	_c.Call.Return(run)
	return _c
}

// RetrieveByID provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) RetrieveByID(ctx context.Context, domainID string, id string) (bootstrap.Config, error) {
	ret := _mock.Called(ctx, domainID, id)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveByID")
	}

	var r0 bootstrap.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bootstrap.Config, error)); ok {
		return returnFunc(ctx, domainID, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bootstrap.Config); ok {
		r0 = returnFunc(ctx, domainID, id)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, domainID, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConfigRepository_RetrieveByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveByID'
type ConfigRepository_RetrieveByID_Call struct {
	*mock.Call
}

// RetrieveByID is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - id string
func (_e *ConfigRepository_Expecter) RetrieveByID(ctx interface{}, domainID interface{}, id interface{}) *ConfigRepository_RetrieveByID_Call {
	return &ConfigRepository_RetrieveByID_Call{Call: _e.mock.On("RetrieveByID", ctx, domainID, id)}
}

func (_c *ConfigRepository_RetrieveByID_Call) Run(run func(ctx context.Context, domainID string, id string)) *ConfigRepository_RetrieveByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConfigRepository_RetrieveByID_Call) Return(config bootstrap.Config, err error) *ConfigRepository_RetrieveByID_Call {
	_c.Call.Return(config, err)
	return _c
}

func (_c *ConfigRepository_RetrieveByID_Call) RunAndReturn(run func(ctx context.Context, domainID string, id string) (bootstrap.Config, error)) *ConfigRepository_RetrieveByID_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) Save(ctx context.Context, cfg bootstrap.Config, chsConnIDs []string) (string, error) {
	ret := _mock.Called(ctx, cfg, chsConnIDs)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bootstrap.Config, []string) (string, error)); ok {
		return returnFunc(ctx, cfg, chsConnIDs)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bootstrap.Config, []string) string); ok {
		r0 = returnFunc(ctx, cfg, chsConnIDs)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bootstrap.Config, []string) error); ok {
		r1 = returnFunc(ctx, cfg, chsConnIDs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConfigRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type ConfigRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg bootstrap.Config
//   - chsConnIDs []string
func (_e *ConfigRepository_Expecter) Save(ctx interface{}, cfg interface{}, chsConnIDs interface{}) *ConfigRepository_Save_Call {
	return &ConfigRepository_Save_Call{Call: _e.mock.On("Save", ctx, cfg, chsConnIDs)}
}

func (_c *ConfigRepository_Save_Call) Run(run func(ctx context.Context, cfg bootstrap.Config, chsConnIDs []string)) *ConfigRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bootstrap.Config
		if args[1] != nil {
			arg1 = args[1].(bootstrap.Config)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ConfigRepository_Save_Call) Return(s string, err error) *ConfigRepository_Save_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *ConfigRepository_Save_Call) RunAndReturn(run func(ctx context.Context, cfg bootstrap.Config, chsConnIDs []string) (string, error)) *ConfigRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) Update(ctx context.Context, cfg bootstrap.Config) error {
	ret := _mock.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bootstrap.Config) error); ok {
		r0 = returnFunc(ctx, cfg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type ConfigRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg bootstrap.Config
func (_e *ConfigRepository_Expecter) Update(ctx interface{}, cfg interface{}) *ConfigRepository_Update_Call {
	return &ConfigRepository_Update_Call{Call: _e.mock.On("Update", ctx, cfg)}
}

func (_c *ConfigRepository_Update_Call) Run(run func(ctx context.Context, cfg bootstrap.Config)) *ConfigRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bootstrap.Config
		if args[1] != nil {
			arg1 = args[1].(bootstrap.Config)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConfigRepository_Update_Call) Return(err error) *ConfigRepository_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_Update_Call) RunAndReturn(run func(ctx context.Context, cfg bootstrap.Config) error) *ConfigRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCert provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) UpdateCert(ctx context.Context, domainID string, clientID string, clientCert string, clientKey string, caCert string) (bootstrap.Config, error) {
	ret := _mock.Called(ctx, domainID, clientID, clientCert, clientKey, caCert)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCert")
	}

	var r0 bootstrap.Config
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string) (bootstrap.Config, error)); ok {
		return returnFunc(ctx, domainID, clientID, clientCert, clientKey, caCert)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string) bootstrap.Config); ok {
		r0 = returnFunc(ctx, domainID, clientID, clientCert, clientKey, caCert)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, domainID, clientID, clientCert, clientKey, caCert)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ConfigRepository_UpdateCert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCert'
type ConfigRepository_UpdateCert_Call struct {
	*mock.Call
}

// UpdateCert is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - clientID string
//   - clientCert string
//   - clientKey string
//   - caCert string
func (_e *ConfigRepository_Expecter) UpdateCert(ctx interface{}, domainID interface{}, clientID interface{}, clientCert interface{}, clientKey interface{}, caCert interface{}) *ConfigRepository_UpdateCert_Call {
	return &ConfigRepository_UpdateCert_Call{Call: _e.mock.On("UpdateCert", ctx, domainID, clientID, clientCert, clientKey, caCert)}
}

func (_c *ConfigRepository_UpdateCert_Call) Run(run func(ctx context.Context, domainID string, clientID string, clientCert string, clientKey string, caCert string)) *ConfigRepository_UpdateCert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *ConfigRepository_UpdateCert_Call) Return(config bootstrap.Config, err error) *ConfigRepository_UpdateCert_Call {
	_c.Call.Return(config, err)
	return _c
}

func (_c *ConfigRepository_UpdateCert_Call) RunAndReturn(run func(ctx context.Context, domainID string, clientID string, clientCert string, clientKey string, caCert string) (bootstrap.Config, error)) *ConfigRepository_UpdateCert_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateChannel provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) UpdateChannel(ctx context.Context, c bootstrap.Channel) error {
	ret := _mock.Called(ctx, c)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bootstrap.Channel) error); ok {
		r0 = returnFunc(ctx, c)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_UpdateChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateChannel'
type ConfigRepository_UpdateChannel_Call struct {
	*mock.Call
}

// UpdateChannel is a helper method to define mock.On call
//   - ctx context.Context
//   - c bootstrap.Channel
func (_e *ConfigRepository_Expecter) UpdateChannel(ctx interface{}, c interface{}) *ConfigRepository_UpdateChannel_Call {
	return &ConfigRepository_UpdateChannel_Call{Call: _e.mock.On("UpdateChannel", ctx, c)}
}

func (_c *ConfigRepository_UpdateChannel_Call) Run(run func(ctx context.Context, c bootstrap.Channel)) *ConfigRepository_UpdateChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bootstrap.Channel
		if args[1] != nil {
			arg1 = args[1].(bootstrap.Channel)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ConfigRepository_UpdateChannel_Call) Return(err error) *ConfigRepository_UpdateChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_UpdateChannel_Call) RunAndReturn(run func(ctx context.Context, c bootstrap.Channel) error) *ConfigRepository_UpdateChannel_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConnections provides a mock function for the type ConfigRepository
func (_mock *ConfigRepository) UpdateConnections(ctx context.Context, domainID string, id string, channels []bootstrap.Channel, connections []string) error {
	ret := _mock.Called(ctx, domainID, id, channels, connections)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnections")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, []bootstrap.Channel, []string) error); ok {
		r0 = returnFunc(ctx, domainID, id, channels, connections)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ConfigRepository_UpdateConnections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConnections'
type ConfigRepository_UpdateConnections_Call struct {
	*mock.Call
}

// UpdateConnections is a helper method to define mock.On call
//   - ctx context.Context
//   - domainID string
//   - id string
//   - channels []bootstrap.Channel
//   - connections []string
func (_e *ConfigRepository_Expecter) UpdateConnections(ctx interface{}, domainID interface{}, id interface{}, channels interface{}, connections interface{}) *ConfigRepository_UpdateConnections_Call {
	return &ConfigRepository_UpdateConnections_Call{Call: _e.mock.On("UpdateConnections", ctx, domainID, id, channels, connections)}
}

func (_c *ConfigRepository_UpdateConnections_Call) Run(run func(ctx context.Context, domainID string, id string, channels []bootstrap.Channel, connections []string)) *ConfigRepository_UpdateConnections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []bootstrap.Channel
		if args[3] != nil {
			arg3 = args[3].([]bootstrap.Channel)
		}
		var arg4 []string
		if args[4] != nil {
			arg4 = args[4].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *ConfigRepository_UpdateConnections_Call) Return(err error) *ConfigRepository_UpdateConnections_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ConfigRepository_UpdateConnections_Call) RunAndReturn(run func(ctx context.Context, domainID string, id string, channels []bootstrap.Channel, connections []string) error) *ConfigRepository_UpdateConnections_Call {
	_c.Call.Return(run)
	return _c
}
