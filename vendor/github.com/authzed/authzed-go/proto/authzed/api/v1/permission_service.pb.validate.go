// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: authzed/api/v1/permission_service.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Consistency with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Consistency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Consistency with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConsistencyMultiError, or
// nil if none found.
func (m *Consistency) ValidateAll() error {
	return m.validate(true)
}

func (m *Consistency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofRequirementPresent := false
	switch v := m.Requirement.(type) {
	case *Consistency_MinimizeLatency:
		if v == nil {
			err := ConsistencyValidationError{
				field:  "Requirement",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequirementPresent = true

		if m.GetMinimizeLatency() != true {
			err := ConsistencyValidationError{
				field:  "MinimizeLatency",
				reason: "value must equal true",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *Consistency_AtLeastAsFresh:
		if v == nil {
			err := ConsistencyValidationError{
				field:  "Requirement",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequirementPresent = true

		if all {
			switch v := interface{}(m.GetAtLeastAsFresh()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConsistencyValidationError{
						field:  "AtLeastAsFresh",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConsistencyValidationError{
						field:  "AtLeastAsFresh",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAtLeastAsFresh()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConsistencyValidationError{
					field:  "AtLeastAsFresh",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Consistency_AtExactSnapshot:
		if v == nil {
			err := ConsistencyValidationError{
				field:  "Requirement",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequirementPresent = true

		if all {
			switch v := interface{}(m.GetAtExactSnapshot()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConsistencyValidationError{
						field:  "AtExactSnapshot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConsistencyValidationError{
						field:  "AtExactSnapshot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAtExactSnapshot()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConsistencyValidationError{
					field:  "AtExactSnapshot",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Consistency_FullyConsistent:
		if v == nil {
			err := ConsistencyValidationError{
				field:  "Requirement",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequirementPresent = true

		if m.GetFullyConsistent() != true {
			err := ConsistencyValidationError{
				field:  "FullyConsistent",
				reason: "value must equal true",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofRequirementPresent {
		err := ConsistencyValidationError{
			field:  "Requirement",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConsistencyMultiError(errors)
	}

	return nil
}

// ConsistencyMultiError is an error wrapping multiple validation errors
// returned by Consistency.ValidateAll() if the designated constraints aren't met.
type ConsistencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsistencyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsistencyMultiError) AllErrors() []error { return m }

// ConsistencyValidationError is the validation error returned by
// Consistency.Validate if the designated constraints aren't met.
type ConsistencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsistencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsistencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsistencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsistencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsistencyValidationError) ErrorName() string { return "ConsistencyValidationError" }

// Error satisfies the builtin error interface
func (e ConsistencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsistency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsistencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsistencyValidationError{}

// Validate checks the field values on RelationshipFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RelationshipFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationshipFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationshipFilterMultiError, or nil if none found.
func (m *RelationshipFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationshipFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetResourceType()) > 128 {
		err := RelationshipFilterValidationError{
			field:  "ResourceType",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RelationshipFilter_ResourceType_Pattern.MatchString(m.GetResourceType()) {
		err := RelationshipFilterValidationError{
			field:  "ResourceType",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOptionalResourceId()) > 1024 {
		err := RelationshipFilterValidationError{
			field:  "OptionalResourceId",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RelationshipFilter_OptionalResourceId_Pattern.MatchString(m.GetOptionalResourceId()) {
		err := RelationshipFilterValidationError{
			field:  "OptionalResourceId",
			reason: "value does not match regex pattern \"^([a-zA-Z0-9/_|\\\\-=+]{1,})?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOptionalRelation()) > 64 {
		err := RelationshipFilterValidationError{
			field:  "OptionalRelation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RelationshipFilter_OptionalRelation_Pattern.MatchString(m.GetOptionalRelation()) {
		err := RelationshipFilterValidationError{
			field:  "OptionalRelation",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptionalSubjectFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationshipFilterValidationError{
					field:  "OptionalSubjectFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationshipFilterValidationError{
					field:  "OptionalSubjectFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalSubjectFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationshipFilterValidationError{
				field:  "OptionalSubjectFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RelationshipFilterMultiError(errors)
	}

	return nil
}

// RelationshipFilterMultiError is an error wrapping multiple validation errors
// returned by RelationshipFilter.ValidateAll() if the designated constraints
// aren't met.
type RelationshipFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationshipFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationshipFilterMultiError) AllErrors() []error { return m }

// RelationshipFilterValidationError is the validation error returned by
// RelationshipFilter.Validate if the designated constraints aren't met.
type RelationshipFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationshipFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationshipFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationshipFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationshipFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationshipFilterValidationError) ErrorName() string {
	return "RelationshipFilterValidationError"
}

// Error satisfies the builtin error interface
func (e RelationshipFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationshipFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationshipFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationshipFilterValidationError{}

var _RelationshipFilter_ResourceType_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _RelationshipFilter_OptionalResourceId_Pattern = regexp.MustCompile("^([a-zA-Z0-9/_|\\-=+]{1,})?$")

var _RelationshipFilter_OptionalRelation_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on SubjectFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubjectFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubjectFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubjectFilterMultiError, or
// nil if none found.
func (m *SubjectFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *SubjectFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSubjectType()) > 128 {
		err := SubjectFilterValidationError{
			field:  "SubjectType",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SubjectFilter_SubjectType_Pattern.MatchString(m.GetSubjectType()) {
		err := SubjectFilterValidationError{
			field:  "SubjectType",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOptionalSubjectId()) > 1024 {
		err := SubjectFilterValidationError{
			field:  "OptionalSubjectId",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SubjectFilter_OptionalSubjectId_Pattern.MatchString(m.GetOptionalSubjectId()) {
		err := SubjectFilterValidationError{
			field:  "OptionalSubjectId",
			reason: "value does not match regex pattern \"^(([a-zA-Z0-9/_|\\\\-=+]{1,})|\\\\*)?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptionalRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubjectFilterValidationError{
					field:  "OptionalRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubjectFilterValidationError{
					field:  "OptionalRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubjectFilterValidationError{
				field:  "OptionalRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubjectFilterMultiError(errors)
	}

	return nil
}

// SubjectFilterMultiError is an error wrapping multiple validation errors
// returned by SubjectFilter.ValidateAll() if the designated constraints
// aren't met.
type SubjectFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubjectFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubjectFilterMultiError) AllErrors() []error { return m }

// SubjectFilterValidationError is the validation error returned by
// SubjectFilter.Validate if the designated constraints aren't met.
type SubjectFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubjectFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubjectFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubjectFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubjectFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubjectFilterValidationError) ErrorName() string { return "SubjectFilterValidationError" }

// Error satisfies the builtin error interface
func (e SubjectFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubjectFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubjectFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubjectFilterValidationError{}

var _SubjectFilter_SubjectType_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _SubjectFilter_OptionalSubjectId_Pattern = regexp.MustCompile("^(([a-zA-Z0-9/_|\\-=+]{1,})|\\*)?$")

// Validate checks the field values on ReadRelationshipsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadRelationshipsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadRelationshipsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadRelationshipsRequestMultiError, or nil if none found.
func (m *ReadRelationshipsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadRelationshipsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRelationshipsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRelationshipsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRelationshipsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRelationshipFilter() == nil {
		err := ReadRelationshipsRequestValidationError{
			field:  "RelationshipFilter",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRelationshipFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRelationshipsRequestValidationError{
					field:  "RelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRelationshipsRequestValidationError{
					field:  "RelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelationshipFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRelationshipsRequestValidationError{
				field:  "RelationshipFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetOptionalLimit(); val < 0 || val > 1000 {
		err := ReadRelationshipsRequestValidationError{
			field:  "OptionalLimit",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRelationshipsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRelationshipsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRelationshipsRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadRelationshipsRequestMultiError(errors)
	}

	return nil
}

// ReadRelationshipsRequestMultiError is an error wrapping multiple validation
// errors returned by ReadRelationshipsRequest.ValidateAll() if the designated
// constraints aren't met.
type ReadRelationshipsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadRelationshipsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadRelationshipsRequestMultiError) AllErrors() []error { return m }

// ReadRelationshipsRequestValidationError is the validation error returned by
// ReadRelationshipsRequest.Validate if the designated constraints aren't met.
type ReadRelationshipsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadRelationshipsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadRelationshipsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadRelationshipsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadRelationshipsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadRelationshipsRequestValidationError) ErrorName() string {
	return "ReadRelationshipsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadRelationshipsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadRelationshipsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadRelationshipsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadRelationshipsRequestValidationError{}

// Validate checks the field values on ReadRelationshipsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadRelationshipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadRelationshipsResponseMultiError, or nil if none found.
func (m *ReadRelationshipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadRelationshipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetReadAt() == nil {
		err := ReadRelationshipsResponseValidationError{
			field:  "ReadAt",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRelationshipsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRelationshipsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRelationshipsResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRelationship() == nil {
		err := ReadRelationshipsResponseValidationError{
			field:  "Relationship",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRelationship()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRelationshipsResponseValidationError{
					field:  "Relationship",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRelationshipsResponseValidationError{
					field:  "Relationship",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelationship()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRelationshipsResponseValidationError{
				field:  "Relationship",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfterResultCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadRelationshipsResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadRelationshipsResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResultCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadRelationshipsResponseValidationError{
				field:  "AfterResultCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadRelationshipsResponseMultiError(errors)
	}

	return nil
}

// ReadRelationshipsResponseMultiError is an error wrapping multiple validation
// errors returned by ReadRelationshipsResponse.ValidateAll() if the
// designated constraints aren't met.
type ReadRelationshipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadRelationshipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadRelationshipsResponseMultiError) AllErrors() []error { return m }

// ReadRelationshipsResponseValidationError is the validation error returned by
// ReadRelationshipsResponse.Validate if the designated constraints aren't met.
type ReadRelationshipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadRelationshipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadRelationshipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadRelationshipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadRelationshipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadRelationshipsResponseValidationError) ErrorName() string {
	return "ReadRelationshipsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadRelationshipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadRelationshipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadRelationshipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadRelationshipsResponseValidationError{}

// Validate checks the field values on Precondition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Precondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Precondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PreconditionMultiError, or
// nil if none found.
func (m *Precondition) ValidateAll() error {
	return m.validate(true)
}

func (m *Precondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _Precondition_Operation_NotInLookup[m.GetOperation()]; ok {
		err := PreconditionValidationError{
			field:  "Operation",
			reason: "value must not be in list [OPERATION_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := Precondition_Operation_name[int32(m.GetOperation())]; !ok {
		err := PreconditionValidationError{
			field:  "Operation",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFilter() == nil {
		err := PreconditionValidationError{
			field:  "Filter",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreconditionValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreconditionValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreconditionValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PreconditionMultiError(errors)
	}

	return nil
}

// PreconditionMultiError is an error wrapping multiple validation errors
// returned by Precondition.ValidateAll() if the designated constraints aren't met.
type PreconditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreconditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreconditionMultiError) AllErrors() []error { return m }

// PreconditionValidationError is the validation error returned by
// Precondition.Validate if the designated constraints aren't met.
type PreconditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreconditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreconditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreconditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreconditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreconditionValidationError) ErrorName() string { return "PreconditionValidationError" }

// Error satisfies the builtin error interface
func (e PreconditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrecondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreconditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreconditionValidationError{}

var _Precondition_Operation_NotInLookup = map[Precondition_Operation]struct{}{
	0: {},
}

// Validate checks the field values on WriteRelationshipsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteRelationshipsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteRelationshipsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteRelationshipsRequestMultiError, or nil if none found.
func (m *WriteRelationshipsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteRelationshipsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUpdates() {
		_, _ = idx, item

		if item == nil {
			err := WriteRelationshipsRequestValidationError{
				field:  fmt.Sprintf("Updates[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WriteRelationshipsRequestValidationError{
						field:  fmt.Sprintf("Updates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WriteRelationshipsRequestValidationError{
						field:  fmt.Sprintf("Updates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WriteRelationshipsRequestValidationError{
					field:  fmt.Sprintf("Updates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOptionalPreconditions() {
		_, _ = idx, item

		if item == nil {
			err := WriteRelationshipsRequestValidationError{
				field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WriteRelationshipsRequestValidationError{
						field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WriteRelationshipsRequestValidationError{
						field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WriteRelationshipsRequestValidationError{
					field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WriteRelationshipsRequestMultiError(errors)
	}

	return nil
}

// WriteRelationshipsRequestMultiError is an error wrapping multiple validation
// errors returned by WriteRelationshipsRequest.ValidateAll() if the
// designated constraints aren't met.
type WriteRelationshipsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteRelationshipsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteRelationshipsRequestMultiError) AllErrors() []error { return m }

// WriteRelationshipsRequestValidationError is the validation error returned by
// WriteRelationshipsRequest.Validate if the designated constraints aren't met.
type WriteRelationshipsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteRelationshipsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteRelationshipsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteRelationshipsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteRelationshipsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteRelationshipsRequestValidationError) ErrorName() string {
	return "WriteRelationshipsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WriteRelationshipsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteRelationshipsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteRelationshipsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteRelationshipsRequestValidationError{}

// Validate checks the field values on WriteRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteRelationshipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteRelationshipsResponseMultiError, or nil if none found.
func (m *WriteRelationshipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteRelationshipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWrittenAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WriteRelationshipsResponseValidationError{
					field:  "WrittenAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WriteRelationshipsResponseValidationError{
					field:  "WrittenAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrittenAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WriteRelationshipsResponseValidationError{
				field:  "WrittenAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WriteRelationshipsResponseMultiError(errors)
	}

	return nil
}

// WriteRelationshipsResponseMultiError is an error wrapping multiple
// validation errors returned by WriteRelationshipsResponse.ValidateAll() if
// the designated constraints aren't met.
type WriteRelationshipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteRelationshipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteRelationshipsResponseMultiError) AllErrors() []error { return m }

// WriteRelationshipsResponseValidationError is the validation error returned
// by WriteRelationshipsResponse.Validate if the designated constraints aren't met.
type WriteRelationshipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteRelationshipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteRelationshipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteRelationshipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteRelationshipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteRelationshipsResponseValidationError) ErrorName() string {
	return "WriteRelationshipsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WriteRelationshipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteRelationshipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteRelationshipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteRelationshipsResponseValidationError{}

// Validate checks the field values on DeleteRelationshipsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRelationshipsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRelationshipsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRelationshipsRequestMultiError, or nil if none found.
func (m *DeleteRelationshipsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRelationshipsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRelationshipFilter() == nil {
		err := DeleteRelationshipsRequestValidationError{
			field:  "RelationshipFilter",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRelationshipFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRelationshipsRequestValidationError{
					field:  "RelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRelationshipsRequestValidationError{
					field:  "RelationshipFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelationshipFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRelationshipsRequestValidationError{
				field:  "RelationshipFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOptionalPreconditions() {
		_, _ = idx, item

		if item == nil {
			err := DeleteRelationshipsRequestValidationError{
				field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteRelationshipsRequestValidationError{
						field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteRelationshipsRequestValidationError{
						field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteRelationshipsRequestValidationError{
					field:  fmt.Sprintf("OptionalPreconditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if val := m.GetOptionalLimit(); val < 0 || val > 1000 {
		err := DeleteRelationshipsRequestValidationError{
			field:  "OptionalLimit",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OptionalAllowPartialDeletions

	if len(errors) > 0 {
		return DeleteRelationshipsRequestMultiError(errors)
	}

	return nil
}

// DeleteRelationshipsRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteRelationshipsRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteRelationshipsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRelationshipsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRelationshipsRequestMultiError) AllErrors() []error { return m }

// DeleteRelationshipsRequestValidationError is the validation error returned
// by DeleteRelationshipsRequest.Validate if the designated constraints aren't met.
type DeleteRelationshipsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRelationshipsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRelationshipsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRelationshipsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRelationshipsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRelationshipsRequestValidationError) ErrorName() string {
	return "DeleteRelationshipsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRelationshipsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRelationshipsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRelationshipsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRelationshipsRequestValidationError{}

// Validate checks the field values on DeleteRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRelationshipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRelationshipsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRelationshipsResponseMultiError, or nil if none found.
func (m *DeleteRelationshipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRelationshipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRelationshipsResponseValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRelationshipsResponseValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRelationshipsResponseValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeletionProgress

	if len(errors) > 0 {
		return DeleteRelationshipsResponseMultiError(errors)
	}

	return nil
}

// DeleteRelationshipsResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteRelationshipsResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteRelationshipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRelationshipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRelationshipsResponseMultiError) AllErrors() []error { return m }

// DeleteRelationshipsResponseValidationError is the validation error returned
// by DeleteRelationshipsResponse.Validate if the designated constraints
// aren't met.
type DeleteRelationshipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRelationshipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRelationshipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRelationshipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRelationshipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRelationshipsResponseValidationError) ErrorName() string {
	return "DeleteRelationshipsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRelationshipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRelationshipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRelationshipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRelationshipsResponseValidationError{}

// Validate checks the field values on CheckPermissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckPermissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckPermissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckPermissionRequestMultiError, or nil if none found.
func (m *CheckPermissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckPermissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckPermissionRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResource() == nil {
		err := CheckPermissionRequestValidationError{
			field:  "Resource",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckPermissionRequestValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetPermission()) > 64 {
		err := CheckPermissionRequestValidationError{
			field:  "Permission",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CheckPermissionRequest_Permission_Pattern.MatchString(m.GetPermission()) {
		err := CheckPermissionRequestValidationError{
			field:  "Permission",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSubject() == nil {
		err := CheckPermissionRequestValidationError{
			field:  "Subject",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckPermissionRequestValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckPermissionRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckPermissionRequestValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckPermissionRequestMultiError(errors)
	}

	return nil
}

// CheckPermissionRequestMultiError is an error wrapping multiple validation
// errors returned by CheckPermissionRequest.ValidateAll() if the designated
// constraints aren't met.
type CheckPermissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckPermissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckPermissionRequestMultiError) AllErrors() []error { return m }

// CheckPermissionRequestValidationError is the validation error returned by
// CheckPermissionRequest.Validate if the designated constraints aren't met.
type CheckPermissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckPermissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckPermissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckPermissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckPermissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckPermissionRequestValidationError) ErrorName() string {
	return "CheckPermissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckPermissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckPermissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckPermissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckPermissionRequestValidationError{}

var _CheckPermissionRequest_Permission_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on CheckPermissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckPermissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckPermissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckPermissionResponseMultiError, or nil if none found.
func (m *CheckPermissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckPermissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCheckedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckPermissionResponseValidationError{
					field:  "CheckedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckPermissionResponseValidationError{
					field:  "CheckedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckPermissionResponseValidationError{
				field:  "CheckedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _CheckPermissionResponse_Permissionship_NotInLookup[m.GetPermissionship()]; ok {
		err := CheckPermissionResponseValidationError{
			field:  "Permissionship",
			reason: "value must not be in list [PERMISSIONSHIP_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := CheckPermissionResponse_Permissionship_name[int32(m.GetPermissionship())]; !ok {
		err := CheckPermissionResponseValidationError{
			field:  "Permissionship",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialCaveatInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckPermissionResponseValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckPermissionResponseValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialCaveatInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckPermissionResponseValidationError{
				field:  "PartialCaveatInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckPermissionResponseMultiError(errors)
	}

	return nil
}

// CheckPermissionResponseMultiError is an error wrapping multiple validation
// errors returned by CheckPermissionResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckPermissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckPermissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckPermissionResponseMultiError) AllErrors() []error { return m }

// CheckPermissionResponseValidationError is the validation error returned by
// CheckPermissionResponse.Validate if the designated constraints aren't met.
type CheckPermissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckPermissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckPermissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckPermissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckPermissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckPermissionResponseValidationError) ErrorName() string {
	return "CheckPermissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckPermissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckPermissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckPermissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckPermissionResponseValidationError{}

var _CheckPermissionResponse_Permissionship_NotInLookup = map[CheckPermissionResponse_Permissionship]struct{}{
	0: {},
}

// Validate checks the field values on ExpandPermissionTreeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpandPermissionTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpandPermissionTreeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpandPermissionTreeRequestMultiError, or nil if none found.
func (m *ExpandPermissionTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpandPermissionTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpandPermissionTreeRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpandPermissionTreeRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpandPermissionTreeRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResource() == nil {
		err := ExpandPermissionTreeRequestValidationError{
			field:  "Resource",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpandPermissionTreeRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpandPermissionTreeRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpandPermissionTreeRequestValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetPermission()) > 64 {
		err := ExpandPermissionTreeRequestValidationError{
			field:  "Permission",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ExpandPermissionTreeRequest_Permission_Pattern.MatchString(m.GetPermission()) {
		err := ExpandPermissionTreeRequestValidationError{
			field:  "Permission",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExpandPermissionTreeRequestMultiError(errors)
	}

	return nil
}

// ExpandPermissionTreeRequestMultiError is an error wrapping multiple
// validation errors returned by ExpandPermissionTreeRequest.ValidateAll() if
// the designated constraints aren't met.
type ExpandPermissionTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpandPermissionTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpandPermissionTreeRequestMultiError) AllErrors() []error { return m }

// ExpandPermissionTreeRequestValidationError is the validation error returned
// by ExpandPermissionTreeRequest.Validate if the designated constraints
// aren't met.
type ExpandPermissionTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpandPermissionTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpandPermissionTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpandPermissionTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpandPermissionTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpandPermissionTreeRequestValidationError) ErrorName() string {
	return "ExpandPermissionTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExpandPermissionTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpandPermissionTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpandPermissionTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpandPermissionTreeRequestValidationError{}

var _ExpandPermissionTreeRequest_Permission_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on ExpandPermissionTreeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExpandPermissionTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpandPermissionTreeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExpandPermissionTreeResponseMultiError, or nil if none found.
func (m *ExpandPermissionTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpandPermissionTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpandedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpandPermissionTreeResponseValidationError{
					field:  "ExpandedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpandPermissionTreeResponseValidationError{
					field:  "ExpandedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpandedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpandPermissionTreeResponseValidationError{
				field:  "ExpandedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTreeRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpandPermissionTreeResponseValidationError{
					field:  "TreeRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpandPermissionTreeResponseValidationError{
					field:  "TreeRoot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTreeRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpandPermissionTreeResponseValidationError{
				field:  "TreeRoot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpandPermissionTreeResponseMultiError(errors)
	}

	return nil
}

// ExpandPermissionTreeResponseMultiError is an error wrapping multiple
// validation errors returned by ExpandPermissionTreeResponse.ValidateAll() if
// the designated constraints aren't met.
type ExpandPermissionTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpandPermissionTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpandPermissionTreeResponseMultiError) AllErrors() []error { return m }

// ExpandPermissionTreeResponseValidationError is the validation error returned
// by ExpandPermissionTreeResponse.Validate if the designated constraints
// aren't met.
type ExpandPermissionTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpandPermissionTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpandPermissionTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpandPermissionTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpandPermissionTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpandPermissionTreeResponseValidationError) ErrorName() string {
	return "ExpandPermissionTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExpandPermissionTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpandPermissionTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpandPermissionTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpandPermissionTreeResponseValidationError{}

// Validate checks the field values on LookupResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LookupResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LookupResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LookupResourcesRequestMultiError, or nil if none found.
func (m *LookupResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LookupResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetResourceObjectType()) > 128 {
		err := LookupResourcesRequestValidationError{
			field:  "ResourceObjectType",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LookupResourcesRequest_ResourceObjectType_Pattern.MatchString(m.GetResourceObjectType()) {
		err := LookupResourcesRequestValidationError{
			field:  "ResourceObjectType",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetPermission()) > 64 {
		err := LookupResourcesRequestValidationError{
			field:  "Permission",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LookupResourcesRequest_Permission_Pattern.MatchString(m.GetPermission()) {
		err := LookupResourcesRequestValidationError{
			field:  "Permission",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSubject() == nil {
		err := LookupResourcesRequestValidationError{
			field:  "Subject",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesRequestValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesRequestValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetOptionalLimit(); val < 0 || val > 1000 {
		err := LookupResourcesRequestValidationError{
			field:  "OptionalLimit",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LookupResourcesRequestMultiError(errors)
	}

	return nil
}

// LookupResourcesRequestMultiError is an error wrapping multiple validation
// errors returned by LookupResourcesRequest.ValidateAll() if the designated
// constraints aren't met.
type LookupResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LookupResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LookupResourcesRequestMultiError) AllErrors() []error { return m }

// LookupResourcesRequestValidationError is the validation error returned by
// LookupResourcesRequest.Validate if the designated constraints aren't met.
type LookupResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LookupResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LookupResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LookupResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LookupResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LookupResourcesRequestValidationError) ErrorName() string {
	return "LookupResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LookupResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLookupResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LookupResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LookupResourcesRequestValidationError{}

var _LookupResourcesRequest_ResourceObjectType_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _LookupResourcesRequest_Permission_Pattern = regexp.MustCompile("^[a-z][a-z0-9_]{1,62}[a-z0-9]$")

// Validate checks the field values on LookupResourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LookupResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LookupResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LookupResourcesResponseMultiError, or nil if none found.
func (m *LookupResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LookupResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLookedUpAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesResponseValidationError{
					field:  "LookedUpAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesResponseValidationError{
					field:  "LookedUpAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLookedUpAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesResponseValidationError{
				field:  "LookedUpAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ResourceObjectId

	if _, ok := _LookupResourcesResponse_Permissionship_NotInLookup[m.GetPermissionship()]; ok {
		err := LookupResourcesResponseValidationError{
			field:  "Permissionship",
			reason: "value must not be in list [LOOKUP_PERMISSIONSHIP_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := LookupPermissionship_name[int32(m.GetPermissionship())]; !ok {
		err := LookupResourcesResponseValidationError{
			field:  "Permissionship",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialCaveatInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesResponseValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesResponseValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialCaveatInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesResponseValidationError{
				field:  "PartialCaveatInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfterResultCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupResourcesResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupResourcesResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResultCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupResourcesResponseValidationError{
				field:  "AfterResultCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LookupResourcesResponseMultiError(errors)
	}

	return nil
}

// LookupResourcesResponseMultiError is an error wrapping multiple validation
// errors returned by LookupResourcesResponse.ValidateAll() if the designated
// constraints aren't met.
type LookupResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LookupResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LookupResourcesResponseMultiError) AllErrors() []error { return m }

// LookupResourcesResponseValidationError is the validation error returned by
// LookupResourcesResponse.Validate if the designated constraints aren't met.
type LookupResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LookupResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LookupResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LookupResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LookupResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LookupResourcesResponseValidationError) ErrorName() string {
	return "LookupResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LookupResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLookupResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LookupResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LookupResourcesResponseValidationError{}

var _LookupResourcesResponse_Permissionship_NotInLookup = map[LookupPermissionship]struct{}{
	0: {},
}

// Validate checks the field values on LookupSubjectsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LookupSubjectsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LookupSubjectsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LookupSubjectsRequestMultiError, or nil if none found.
func (m *LookupSubjectsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LookupSubjectsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResource() == nil {
		err := LookupSubjectsRequestValidationError{
			field:  "Resource",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsRequestValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetPermission()) > 64 {
		err := LookupSubjectsRequestValidationError{
			field:  "Permission",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LookupSubjectsRequest_Permission_Pattern.MatchString(m.GetPermission()) {
		err := LookupSubjectsRequestValidationError{
			field:  "Permission",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSubjectObjectType()) > 128 {
		err := LookupSubjectsRequestValidationError{
			field:  "SubjectObjectType",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LookupSubjectsRequest_SubjectObjectType_Pattern.MatchString(m.GetSubjectObjectType()) {
		err := LookupSubjectsRequestValidationError{
			field:  "SubjectObjectType",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOptionalSubjectRelation()) > 64 {
		err := LookupSubjectsRequestValidationError{
			field:  "OptionalSubjectRelation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LookupSubjectsRequest_OptionalSubjectRelation_Pattern.MatchString(m.GetOptionalSubjectRelation()) {
		err := LookupSubjectsRequestValidationError{
			field:  "OptionalSubjectRelation",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsRequestValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetOptionalConcreteLimit(); val < 0 || val > 1000 {
		err := LookupSubjectsRequestValidationError{
			field:  "OptionalConcreteLimit",
			reason: "value must be inside range [0, 1000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WildcardOption

	if len(errors) > 0 {
		return LookupSubjectsRequestMultiError(errors)
	}

	return nil
}

// LookupSubjectsRequestMultiError is an error wrapping multiple validation
// errors returned by LookupSubjectsRequest.ValidateAll() if the designated
// constraints aren't met.
type LookupSubjectsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LookupSubjectsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LookupSubjectsRequestMultiError) AllErrors() []error { return m }

// LookupSubjectsRequestValidationError is the validation error returned by
// LookupSubjectsRequest.Validate if the designated constraints aren't met.
type LookupSubjectsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LookupSubjectsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LookupSubjectsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LookupSubjectsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LookupSubjectsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LookupSubjectsRequestValidationError) ErrorName() string {
	return "LookupSubjectsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LookupSubjectsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLookupSubjectsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LookupSubjectsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LookupSubjectsRequestValidationError{}

var _LookupSubjectsRequest_Permission_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

var _LookupSubjectsRequest_SubjectObjectType_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _LookupSubjectsRequest_OptionalSubjectRelation_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")

// Validate checks the field values on LookupSubjectsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LookupSubjectsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LookupSubjectsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LookupSubjectsResponseMultiError, or nil if none found.
func (m *LookupSubjectsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LookupSubjectsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLookedUpAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "LookedUpAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "LookedUpAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLookedUpAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsResponseValidationError{
				field:  "LookedUpAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SubjectObjectId

	if _, ok := _LookupSubjectsResponse_Permissionship_NotInLookup[m.GetPermissionship()]; ok {
		err := LookupSubjectsResponseValidationError{
			field:  "Permissionship",
			reason: "value must not be in list [LOOKUP_PERMISSIONSHIP_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := LookupPermissionship_name[int32(m.GetPermissionship())]; !ok {
		err := LookupSubjectsResponseValidationError{
			field:  "Permissionship",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialCaveatInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialCaveatInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsResponseValidationError{
				field:  "PartialCaveatInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsResponseValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExcludedSubjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LookupSubjectsResponseValidationError{
						field:  fmt.Sprintf("ExcludedSubjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LookupSubjectsResponseValidationError{
						field:  fmt.Sprintf("ExcludedSubjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LookupSubjectsResponseValidationError{
					field:  fmt.Sprintf("ExcludedSubjects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetAfterResultCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LookupSubjectsResponseValidationError{
					field:  "AfterResultCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResultCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LookupSubjectsResponseValidationError{
				field:  "AfterResultCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LookupSubjectsResponseMultiError(errors)
	}

	return nil
}

// LookupSubjectsResponseMultiError is an error wrapping multiple validation
// errors returned by LookupSubjectsResponse.ValidateAll() if the designated
// constraints aren't met.
type LookupSubjectsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LookupSubjectsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LookupSubjectsResponseMultiError) AllErrors() []error { return m }

// LookupSubjectsResponseValidationError is the validation error returned by
// LookupSubjectsResponse.Validate if the designated constraints aren't met.
type LookupSubjectsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LookupSubjectsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LookupSubjectsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LookupSubjectsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LookupSubjectsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LookupSubjectsResponseValidationError) ErrorName() string {
	return "LookupSubjectsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LookupSubjectsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLookupSubjectsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LookupSubjectsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LookupSubjectsResponseValidationError{}

var _LookupSubjectsResponse_Permissionship_NotInLookup = map[LookupPermissionship]struct{}{
	0: {},
}

// Validate checks the field values on ResolvedSubject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResolvedSubject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolvedSubject with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolvedSubjectMultiError, or nil if none found.
func (m *ResolvedSubject) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolvedSubject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectObjectId

	if _, ok := _ResolvedSubject_Permissionship_NotInLookup[m.GetPermissionship()]; ok {
		err := ResolvedSubjectValidationError{
			field:  "Permissionship",
			reason: "value must not be in list [LOOKUP_PERMISSIONSHIP_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := LookupPermissionship_name[int32(m.GetPermissionship())]; !ok {
		err := ResolvedSubjectValidationError{
			field:  "Permissionship",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialCaveatInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolvedSubjectValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolvedSubjectValidationError{
					field:  "PartialCaveatInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialCaveatInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolvedSubjectValidationError{
				field:  "PartialCaveatInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResolvedSubjectMultiError(errors)
	}

	return nil
}

// ResolvedSubjectMultiError is an error wrapping multiple validation errors
// returned by ResolvedSubject.ValidateAll() if the designated constraints
// aren't met.
type ResolvedSubjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolvedSubjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolvedSubjectMultiError) AllErrors() []error { return m }

// ResolvedSubjectValidationError is the validation error returned by
// ResolvedSubject.Validate if the designated constraints aren't met.
type ResolvedSubjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolvedSubjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolvedSubjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolvedSubjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolvedSubjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolvedSubjectValidationError) ErrorName() string { return "ResolvedSubjectValidationError" }

// Error satisfies the builtin error interface
func (e ResolvedSubjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolvedSubject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolvedSubjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolvedSubjectValidationError{}

var _ResolvedSubject_Permissionship_NotInLookup = map[LookupPermissionship]struct{}{
	0: {},
}

// Validate checks the field values on SubjectFilter_RelationFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubjectFilter_RelationFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubjectFilter_RelationFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubjectFilter_RelationFilterMultiError, or nil if none found.
func (m *SubjectFilter_RelationFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *SubjectFilter_RelationFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRelation()) > 64 {
		err := SubjectFilter_RelationFilterValidationError{
			field:  "Relation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SubjectFilter_RelationFilter_Relation_Pattern.MatchString(m.GetRelation()) {
		err := SubjectFilter_RelationFilterValidationError{
			field:  "Relation",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubjectFilter_RelationFilterMultiError(errors)
	}

	return nil
}

// SubjectFilter_RelationFilterMultiError is an error wrapping multiple
// validation errors returned by SubjectFilter_RelationFilter.ValidateAll() if
// the designated constraints aren't met.
type SubjectFilter_RelationFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubjectFilter_RelationFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubjectFilter_RelationFilterMultiError) AllErrors() []error { return m }

// SubjectFilter_RelationFilterValidationError is the validation error returned
// by SubjectFilter_RelationFilter.Validate if the designated constraints
// aren't met.
type SubjectFilter_RelationFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubjectFilter_RelationFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubjectFilter_RelationFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubjectFilter_RelationFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubjectFilter_RelationFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubjectFilter_RelationFilterValidationError) ErrorName() string {
	return "SubjectFilter_RelationFilterValidationError"
}

// Error satisfies the builtin error interface
func (e SubjectFilter_RelationFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubjectFilter_RelationFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubjectFilter_RelationFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubjectFilter_RelationFilterValidationError{}

var _SubjectFilter_RelationFilter_Relation_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9])?$")
