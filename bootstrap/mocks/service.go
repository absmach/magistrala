// Code generated by mockery v2.43.2. DO NOT EDIT.

// Copyright (c) Abstract Machines

package mocks

import (
	bootstrap "github.com/absmach/supermq/bootstrap"
	authn "github.com/absmach/supermq/pkg/authn"

	context "context"

	mock "github.com/stretchr/testify/mock"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

// Add provides a mock function with given fields: ctx, session, token, cfg
func (_m *Service) Add(ctx context.Context, session authn.Session, token string, cfg bootstrap.Config) (bootstrap.Config, error) {
	ret := _m.Called(ctx, session, token, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 bootstrap.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string, bootstrap.Config) (bootstrap.Config, error)); ok {
		return rf(ctx, session, token, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string, bootstrap.Config) bootstrap.Config); ok {
		r0 = rf(ctx, session, token, cfg)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}

	if rf, ok := ret.Get(1).(func(context.Context, authn.Session, string, bootstrap.Config) error); ok {
		r1 = rf(ctx, session, token, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Bootstrap provides a mock function with given fields: ctx, externalKey, externalID, secure
func (_m *Service) Bootstrap(ctx context.Context, externalKey string, externalID string, secure bool) (bootstrap.Config, error) {
	ret := _m.Called(ctx, externalKey, externalID, secure)

	if len(ret) == 0 {
		panic("no return value specified for Bootstrap")
	}

	var r0 bootstrap.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (bootstrap.Config, error)); ok {
		return rf(ctx, externalKey, externalID, secure)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) bootstrap.Config); ok {
		r0 = rf(ctx, externalKey, externalID, secure)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, externalKey, externalID, secure)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangeState provides a mock function with given fields: ctx, session, token, id, state
func (_m *Service) ChangeState(ctx context.Context, session authn.Session, token string, id string, state bootstrap.State) error {
	ret := _m.Called(ctx, session, token, id, state)

	if len(ret) == 0 {
		panic("no return value specified for ChangeState")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string, string, bootstrap.State) error); ok {
		r0 = rf(ctx, session, token, id, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConnectClientHandler provides a mock function with given fields: ctx, channelID, clientID
func (_m *Service) ConnectClientHandler(ctx context.Context, channelID string, clientID string) error {
	ret := _m.Called(ctx, channelID, clientID)

	if len(ret) == 0 {
		panic("no return value specified for ConnectClientHandler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, channelID, clientID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DisconnectClientHandler provides a mock function with given fields: ctx, channelID, clientID
func (_m *Service) DisconnectClientHandler(ctx context.Context, channelID string, clientID string) error {
	ret := _m.Called(ctx, channelID, clientID)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectClientHandler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, channelID, clientID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// List provides a mock function with given fields: ctx, session, filter, offset, limit
func (_m *Service) List(ctx context.Context, session authn.Session, filter bootstrap.Filter, offset uint64, limit uint64) (bootstrap.ConfigsPage, error) {
	ret := _m.Called(ctx, session, filter, offset, limit)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 bootstrap.ConfigsPage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, bootstrap.Filter, uint64, uint64) (bootstrap.ConfigsPage, error)); ok {
		return rf(ctx, session, filter, offset, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, bootstrap.Filter, uint64, uint64) bootstrap.ConfigsPage); ok {
		r0 = rf(ctx, session, filter, offset, limit)
	} else {
		r0 = ret.Get(0).(bootstrap.ConfigsPage)
	}

	if rf, ok := ret.Get(1).(func(context.Context, authn.Session, bootstrap.Filter, uint64, uint64) error); ok {
		r1 = rf(ctx, session, filter, offset, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remove provides a mock function with given fields: ctx, session, id
func (_m *Service) Remove(ctx context.Context, session authn.Session, id string) error {
	ret := _m.Called(ctx, session, id)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string) error); ok {
		r0 = rf(ctx, session, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveChannelHandler provides a mock function with given fields: ctx, id
func (_m *Service) RemoveChannelHandler(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveChannelHandler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveConfigHandler provides a mock function with given fields: ctx, id
func (_m *Service) RemoveConfigHandler(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveConfigHandler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: ctx, session, cfg
func (_m *Service) Update(ctx context.Context, session authn.Session, cfg bootstrap.Config) error {
	ret := _m.Called(ctx, session, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, bootstrap.Config) error); ok {
		r0 = rf(ctx, session, cfg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCert provides a mock function with given fields: ctx, session, clientID, clientCert, clientKey, caCert
func (_m *Service) UpdateCert(ctx context.Context, session authn.Session, clientID string, clientCert string, clientKey string, caCert string) (bootstrap.Config, error) {
	ret := _m.Called(ctx, session, clientID, clientCert, clientKey, caCert)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCert")
	}

	var r0 bootstrap.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string, string, string, string) (bootstrap.Config, error)); ok {
		return rf(ctx, session, clientID, clientCert, clientKey, caCert)
	}
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string, string, string, string) bootstrap.Config); ok {
		r0 = rf(ctx, session, clientID, clientCert, clientKey, caCert)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}

	if rf, ok := ret.Get(1).(func(context.Context, authn.Session, string, string, string, string) error); ok {
		r1 = rf(ctx, session, clientID, clientCert, clientKey, caCert)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateChannelHandler provides a mock function with given fields: ctx, channel
func (_m *Service) UpdateChannelHandler(ctx context.Context, channel bootstrap.Channel) error {
	ret := _m.Called(ctx, channel)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChannelHandler")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, bootstrap.Channel) error); ok {
		r0 = rf(ctx, channel)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateConnections provides a mock function with given fields: ctx, session, token, id, connections
func (_m *Service) UpdateConnections(ctx context.Context, session authn.Session, token string, id string, connections []string) error {
	ret := _m.Called(ctx, session, token, id, connections)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnections")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string, string, []string) error); ok {
		r0 = rf(ctx, session, token, id, connections)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// View provides a mock function with given fields: ctx, session, id
func (_m *Service) View(ctx context.Context, session authn.Session, id string) (bootstrap.Config, error) {
	ret := _m.Called(ctx, session, id)

	if len(ret) == 0 {
		panic("no return value specified for View")
	}

	var r0 bootstrap.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string) (bootstrap.Config, error)); ok {
		return rf(ctx, session, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, authn.Session, string) bootstrap.Config); ok {
		r0 = rf(ctx, session, id)
	} else {
		r0 = ret.Get(0).(bootstrap.Config)
	}

	if rf, ok := ret.Get(1).(func(context.Context, authn.Session, string) error); ok {
		r1 = rf(ctx, session, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
	mock.TestingT
	Cleanup(func())
}) *Service {
	mock := &Service{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
